// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v6.32.1
// source: api/v1/subscription.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationSubscriptionCreateSubscription = "/sovereign.api.v1.Subscription/CreateSubscription"
const OperationSubscriptionDeleteSubscription = "/sovereign.api.v1.Subscription/DeleteSubscription"
const OperationSubscriptionGetSubscription = "/sovereign.api.v1.Subscription/GetSubscription"
const OperationSubscriptionListSubscription = "/sovereign.api.v1.Subscription/ListSubscription"
const OperationSubscriptionSelectSubscription = "/sovereign.api.v1.Subscription/SelectSubscription"
const OperationSubscriptionUpdateSubscription = "/sovereign.api.v1.Subscription/UpdateSubscription"
const OperationSubscriptionUpdateSubscriptionAlertLevels = "/sovereign.api.v1.Subscription/UpdateSubscriptionAlertLevels"
const OperationSubscriptionUpdateSubscriptionDataSources = "/sovereign.api.v1.Subscription/UpdateSubscriptionDataSources"
const OperationSubscriptionUpdateSubscriptionNotifyTypes = "/sovereign.api.v1.Subscription/UpdateSubscriptionNotifyTypes"
const OperationSubscriptionUpdateSubscriptionStatus = "/sovereign.api.v1.Subscription/UpdateSubscriptionStatus"
const OperationSubscriptionUpdateSubscriptionStrategyGroups = "/sovereign.api.v1.Subscription/UpdateSubscriptionStrategyGroups"

type SubscriptionHTTPServer interface {
	CreateSubscription(context.Context, *CreateSubscriptionRequest) (*CreateSubscriptionReply, error)
	DeleteSubscription(context.Context, *DeleteSubscriptionRequest) (*DeleteSubscriptionReply, error)
	GetSubscription(context.Context, *GetSubscriptionRequest) (*SubscriptionItem, error)
	ListSubscription(context.Context, *ListSubscriptionRequest) (*ListSubscriptionReply, error)
	SelectSubscription(context.Context, *SelectSubscriptionRequest) (*SelectSubscriptionReply, error)
	UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*UpdateSubscriptionReply, error)
	UpdateSubscriptionAlertLevels(context.Context, *UpdateSubscriptionAlertLevelsRequest) (*UpdateSubscriptionAlertLevelsReply, error)
	UpdateSubscriptionDataSources(context.Context, *UpdateSubscriptionDataSourcesRequest) (*UpdateSubscriptionDataSourcesReply, error)
	UpdateSubscriptionNotifyTypes(context.Context, *UpdateSubscriptionNotifyTypesRequest) (*UpdateSubscriptionNotifyTypesReply, error)
	UpdateSubscriptionStatus(context.Context, *UpdateSubscriptionStatusRequest) (*UpdateSubscriptionStatusReply, error)
	UpdateSubscriptionStrategyGroups(context.Context, *UpdateSubscriptionStrategyGroupsRequest) (*UpdateSubscriptionStrategyGroupsReply, error)
}

func RegisterSubscriptionHTTPServer(s *http.Server, srv SubscriptionHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/subscription", _Subscription_CreateSubscription0_HTTP_Handler(srv))
	r.PUT("/v1/subscription/{uid}", _Subscription_UpdateSubscription0_HTTP_Handler(srv))
	r.PUT("/v1/subscription/{uid}/status", _Subscription_UpdateSubscriptionStatus0_HTTP_Handler(srv))
	r.DELETE("/v1/subscription/{uid}", _Subscription_DeleteSubscription0_HTTP_Handler(srv))
	r.GET("/v1/subscription/{uid}", _Subscription_GetSubscription0_HTTP_Handler(srv))
	r.GET("/v1/subscriptions", _Subscription_ListSubscription0_HTTP_Handler(srv))
	r.GET("/v1/subscriptions/select", _Subscription_SelectSubscription0_HTTP_Handler(srv))
	r.PUT("/v1/subscription/{uid}/strategy-groups", _Subscription_UpdateSubscriptionStrategyGroups0_HTTP_Handler(srv))
	r.PUT("/v1/subscription/{uid}/data-sources", _Subscription_UpdateSubscriptionDataSources0_HTTP_Handler(srv))
	r.PUT("/v1/subscription/{uid}/alert-levels", _Subscription_UpdateSubscriptionAlertLevels0_HTTP_Handler(srv))
	r.PUT("/v1/subscription/{uid}/notify-types", _Subscription_UpdateSubscriptionNotifyTypes0_HTTP_Handler(srv))
}

func _Subscription_CreateSubscription0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateSubscriptionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionCreateSubscription)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateSubscription(ctx, req.(*CreateSubscriptionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateSubscriptionReply)
		return ctx.Result(200, reply)
	}
}

func _Subscription_UpdateSubscription0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateSubscriptionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionUpdateSubscription)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateSubscription(ctx, req.(*UpdateSubscriptionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateSubscriptionReply)
		return ctx.Result(200, reply)
	}
}

func _Subscription_UpdateSubscriptionStatus0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateSubscriptionStatusRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionUpdateSubscriptionStatus)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateSubscriptionStatus(ctx, req.(*UpdateSubscriptionStatusRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateSubscriptionStatusReply)
		return ctx.Result(200, reply)
	}
}

func _Subscription_DeleteSubscription0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteSubscriptionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionDeleteSubscription)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteSubscription(ctx, req.(*DeleteSubscriptionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteSubscriptionReply)
		return ctx.Result(200, reply)
	}
}

func _Subscription_GetSubscription0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetSubscriptionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionGetSubscription)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetSubscription(ctx, req.(*GetSubscriptionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SubscriptionItem)
		return ctx.Result(200, reply)
	}
}

func _Subscription_ListSubscription0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListSubscriptionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionListSubscription)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListSubscription(ctx, req.(*ListSubscriptionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListSubscriptionReply)
		return ctx.Result(200, reply)
	}
}

func _Subscription_SelectSubscription0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SelectSubscriptionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionSelectSubscription)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SelectSubscription(ctx, req.(*SelectSubscriptionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SelectSubscriptionReply)
		return ctx.Result(200, reply)
	}
}

func _Subscription_UpdateSubscriptionStrategyGroups0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateSubscriptionStrategyGroupsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionUpdateSubscriptionStrategyGroups)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateSubscriptionStrategyGroups(ctx, req.(*UpdateSubscriptionStrategyGroupsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateSubscriptionStrategyGroupsReply)
		return ctx.Result(200, reply)
	}
}

func _Subscription_UpdateSubscriptionDataSources0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateSubscriptionDataSourcesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionUpdateSubscriptionDataSources)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateSubscriptionDataSources(ctx, req.(*UpdateSubscriptionDataSourcesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateSubscriptionDataSourcesReply)
		return ctx.Result(200, reply)
	}
}

func _Subscription_UpdateSubscriptionAlertLevels0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateSubscriptionAlertLevelsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionUpdateSubscriptionAlertLevels)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateSubscriptionAlertLevels(ctx, req.(*UpdateSubscriptionAlertLevelsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateSubscriptionAlertLevelsReply)
		return ctx.Result(200, reply)
	}
}

func _Subscription_UpdateSubscriptionNotifyTypes0_HTTP_Handler(srv SubscriptionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateSubscriptionNotifyTypesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSubscriptionUpdateSubscriptionNotifyTypes)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateSubscriptionNotifyTypes(ctx, req.(*UpdateSubscriptionNotifyTypesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateSubscriptionNotifyTypesReply)
		return ctx.Result(200, reply)
	}
}

type SubscriptionHTTPClient interface {
	CreateSubscription(ctx context.Context, req *CreateSubscriptionRequest, opts ...http.CallOption) (rsp *CreateSubscriptionReply, err error)
	DeleteSubscription(ctx context.Context, req *DeleteSubscriptionRequest, opts ...http.CallOption) (rsp *DeleteSubscriptionReply, err error)
	GetSubscription(ctx context.Context, req *GetSubscriptionRequest, opts ...http.CallOption) (rsp *SubscriptionItem, err error)
	ListSubscription(ctx context.Context, req *ListSubscriptionRequest, opts ...http.CallOption) (rsp *ListSubscriptionReply, err error)
	SelectSubscription(ctx context.Context, req *SelectSubscriptionRequest, opts ...http.CallOption) (rsp *SelectSubscriptionReply, err error)
	UpdateSubscription(ctx context.Context, req *UpdateSubscriptionRequest, opts ...http.CallOption) (rsp *UpdateSubscriptionReply, err error)
	UpdateSubscriptionAlertLevels(ctx context.Context, req *UpdateSubscriptionAlertLevelsRequest, opts ...http.CallOption) (rsp *UpdateSubscriptionAlertLevelsReply, err error)
	UpdateSubscriptionDataSources(ctx context.Context, req *UpdateSubscriptionDataSourcesRequest, opts ...http.CallOption) (rsp *UpdateSubscriptionDataSourcesReply, err error)
	UpdateSubscriptionNotifyTypes(ctx context.Context, req *UpdateSubscriptionNotifyTypesRequest, opts ...http.CallOption) (rsp *UpdateSubscriptionNotifyTypesReply, err error)
	UpdateSubscriptionStatus(ctx context.Context, req *UpdateSubscriptionStatusRequest, opts ...http.CallOption) (rsp *UpdateSubscriptionStatusReply, err error)
	UpdateSubscriptionStrategyGroups(ctx context.Context, req *UpdateSubscriptionStrategyGroupsRequest, opts ...http.CallOption) (rsp *UpdateSubscriptionStrategyGroupsReply, err error)
}

type SubscriptionHTTPClientImpl struct {
	cc *http.Client
}

func NewSubscriptionHTTPClient(client *http.Client) SubscriptionHTTPClient {
	return &SubscriptionHTTPClientImpl{client}
}

func (c *SubscriptionHTTPClientImpl) CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...http.CallOption) (*CreateSubscriptionReply, error) {
	var out CreateSubscriptionReply
	pattern := "/v1/subscription"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationSubscriptionCreateSubscription))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) DeleteSubscription(ctx context.Context, in *DeleteSubscriptionRequest, opts ...http.CallOption) (*DeleteSubscriptionReply, error) {
	var out DeleteSubscriptionReply
	pattern := "/v1/subscription/{uid}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationSubscriptionDeleteSubscription))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...http.CallOption) (*SubscriptionItem, error) {
	var out SubscriptionItem
	pattern := "/v1/subscription/{uid}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationSubscriptionGetSubscription))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) ListSubscription(ctx context.Context, in *ListSubscriptionRequest, opts ...http.CallOption) (*ListSubscriptionReply, error) {
	var out ListSubscriptionReply
	pattern := "/v1/subscriptions"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationSubscriptionListSubscription))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) SelectSubscription(ctx context.Context, in *SelectSubscriptionRequest, opts ...http.CallOption) (*SelectSubscriptionReply, error) {
	var out SelectSubscriptionReply
	pattern := "/v1/subscriptions/select"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationSubscriptionSelectSubscription))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...http.CallOption) (*UpdateSubscriptionReply, error) {
	var out UpdateSubscriptionReply
	pattern := "/v1/subscription/{uid}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationSubscriptionUpdateSubscription))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) UpdateSubscriptionAlertLevels(ctx context.Context, in *UpdateSubscriptionAlertLevelsRequest, opts ...http.CallOption) (*UpdateSubscriptionAlertLevelsReply, error) {
	var out UpdateSubscriptionAlertLevelsReply
	pattern := "/v1/subscription/{uid}/alert-levels"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationSubscriptionUpdateSubscriptionAlertLevels))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) UpdateSubscriptionDataSources(ctx context.Context, in *UpdateSubscriptionDataSourcesRequest, opts ...http.CallOption) (*UpdateSubscriptionDataSourcesReply, error) {
	var out UpdateSubscriptionDataSourcesReply
	pattern := "/v1/subscription/{uid}/data-sources"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationSubscriptionUpdateSubscriptionDataSources))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) UpdateSubscriptionNotifyTypes(ctx context.Context, in *UpdateSubscriptionNotifyTypesRequest, opts ...http.CallOption) (*UpdateSubscriptionNotifyTypesReply, error) {
	var out UpdateSubscriptionNotifyTypesReply
	pattern := "/v1/subscription/{uid}/notify-types"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationSubscriptionUpdateSubscriptionNotifyTypes))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) UpdateSubscriptionStatus(ctx context.Context, in *UpdateSubscriptionStatusRequest, opts ...http.CallOption) (*UpdateSubscriptionStatusReply, error) {
	var out UpdateSubscriptionStatusReply
	pattern := "/v1/subscription/{uid}/status"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationSubscriptionUpdateSubscriptionStatus))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SubscriptionHTTPClientImpl) UpdateSubscriptionStrategyGroups(ctx context.Context, in *UpdateSubscriptionStrategyGroupsRequest, opts ...http.CallOption) (*UpdateSubscriptionStrategyGroupsReply, error) {
	var out UpdateSubscriptionStrategyGroupsReply
	pattern := "/v1/subscription/{uid}/strategy-groups"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationSubscriptionUpdateSubscriptionStrategyGroups))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
